"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ANCHOR_SLIDE_OFFSET = 0.000000001; // 为了每次设置锚点都能生效，做的一个偏移，一般不用改
Component({
    props: {
        tabs: [],
        activeIndex: 0,
        onTabClick: function (index) { },
        top: 0,
    },
    data: {
        scrollLeft: 0,
        showLeftShadow: false,
        showRightShadow: false,
    },
    anchorPositions: null,
    containerPosition: null,
    didMount: function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.computePosition()];
                    case 1:
                        _a.sent();
                        this.setActivePosition();
                        return [2 /*return*/];
                }
            });
        });
    },
    didUpdate: function (prevProps) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(prevProps.tabs !== this.props.tabs ||
                            prevProps.activeIndex !== this.props.activeIndex)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.computePosition()];
                    case 1:
                        _a.sent();
                        this.setActivePosition();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    },
    methods: {
        onScroll: function () {
            this.computePosition();
        },
        computePosition: function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;
                return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve) {
                            my.createSelectorQuery()
                                .select(".amd-tabs-elevator-bar-items")
                                .boundingClientRect()
                                .selectAll(".amd-tabs-elevator-bar-item")
                                .boundingClientRect()
                                .exec(function (rets) {
                                if (rets) {
                                    var _a = rets, container = _a[0], anchors = _a[1];
                                    if (container && anchors) {
                                        _this.containerPosition = container;
                                        _this.anchorPositions = anchors;
                                        _this.setShadow();
                                    }
                                }
                                resolve(null);
                            });
                        })];
                });
            });
        },
        setShadow: function () {
            var firstAnchor = this.anchorPositions[0];
            var lastAnchor = this.anchorPositions[this.anchorPositions.length - 1];
            if (firstAnchor && lastAnchor) {
                var showLeftShadow = firstAnchor.left < this.containerPosition.left;
                var showRightShadow = lastAnchor.right > this.containerPosition.right;
                if (showLeftShadow !== this.data.showLeftShadow ||
                    showRightShadow !== this.data.showRightShadow) {
                    this.setData({ showLeftShadow: showLeftShadow, showRightShadow: showRightShadow });
                }
            }
        },
        setActivePosition: function () {
            var _this = this;
            var _a = this, containerPosition = _a.containerPosition, anchorPositions = _a.anchorPositions;
            var activeIndex = this.props.activeIndex;
            if (containerPosition &&
                anchorPositions &&
                anchorPositions[activeIndex]) {
                var anchor = anchorPositions[activeIndex];
                if (anchor.left < containerPosition.left ||
                    anchor.right > containerPosition.right) {
                    var scrollLeft_1 = anchorPositions
                        .slice(0, activeIndex)
                        .reduce(function (re, item) { return re + item.width; }, 0);
                    if (scrollLeft_1 === this.data.scrollLeft) {
                        // 设置两次是因为点了锚点A后，用户如果手动滚动列表后，再点A锚点会因为数据相同，而被容器视为不生效
                        this.setData({
                            scrollLeft: scrollLeft_1 + ANCHOR_SLIDE_OFFSET,
                        }, function () {
                            _this.setData({
                                scrollLeft: scrollLeft_1,
                            });
                        });
                    }
                    else {
                        this.setData({
                            scrollLeft: scrollLeft_1,
                        });
                    }
                }
            }
        },
        onTabClick: function (e) {
            this.props.onTabClick(e.target.dataset.index);
        },
    },
});