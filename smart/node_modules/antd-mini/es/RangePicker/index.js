"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var props_1 = require("./props");
var dayjs_1 = tslib_1.__importDefault(require("dayjs"));
var form_1 = tslib_1.__importDefault(require("../mixins/form"));
var computed_1 = tslib_1.__importDefault(require("../mixins/computed"));
var fast_deep_equal_1 = tslib_1.__importDefault(require("fast-deep-equal"));
var util_1 = require("../DatePicker/util");
var fmtEvent_1 = tslib_1.__importDefault(require("../_util/fmtEvent"));
Component({
    mixins: [computed_1.default, (0, form_1.default)({ trigger: 'onOk' })],
    props: props_1.DateRangePickerDefaultProps,
    data: function () {
        return {
            cValue: null,
            currentValue: [],
            columns: [],
            pickerType: 'start',
            currentStartDate: null,
            currentEndDate: null,
            forceUpdate: 0, // 强制更新picker组件，已知需处理的情况：value超限，但是需要更新format，由于picker的参数均未变化，无法触发picker的渲染
        };
    },
    didMount: function () {
        this._visible = false;
        var cValue = this.getValidPropValue();
        this.setData({
            cValue: cValue,
        });
    },
    didUpdate: function (prevProps) {
        var _a, _b, _c, _d;
        if (!(0, util_1.isEqualDate)((_a = prevProps.value) === null || _a === void 0 ? void 0 : _a[0], (_b = this.props.value) === null || _b === void 0 ? void 0 : _b[0]) ||
            !(0, util_1.isEqualDate)((_c = prevProps.value) === null || _c === void 0 ? void 0 : _c[1], (_d = this.props.value) === null || _d === void 0 ? void 0 : _d[1])) {
            var cValue = this.getValidPropValue();
            this.setData({
                cValue: cValue,
                forceUpdate: this.data.forceUpdate + 1,
            });
            if (this._visible) {
                // 展开状态才更新picker的数据，否则下次triggerVisible触发
                this.setCurrentValue();
            }
        }
    },
    methods: {
        // 判断value是否有效
        getValidPropValue: function () {
            var _a = this.props, value = _a.value, min = _a.min, max = _a.max;
            var cValue = null;
            if ((value === null || value === void 0 ? void 0 : value[0]) instanceof Date &&
                (!min || value[0] >= min) &&
                (!max || value[0] <= max)) {
                cValue = [value[0]];
            }
            if ((value === null || value === void 0 ? void 0 : value[1]) instanceof Date &&
                (!min || value[1] >= min) &&
                (!max || value[1] <= max)) {
                if (cValue) {
                    cValue.push(value[1]);
                }
                else {
                    cValue = [null, value[1]];
                }
            }
            return cValue;
        },
        computed: function () {
            var _a = this.data, currentStartDate = _a.currentStartDate, currentEndDate = _a.currentEndDate, pickerType = _a.pickerType;
            var format = this.props.format;
            if (pickerType)
                return {
                    currentStartValueStr: currentStartDate
                        ? (0, dayjs_1.default)(currentStartDate).format(format)
                        : '',
                    currentEndValueStr: currentEndDate
                        ? (0, dayjs_1.default)(currentEndDate).format(format)
                        : '',
                };
        },
        getMin: function () {
            var min = this.props.min;
            var _a = this.data, pickerType = _a.pickerType, currentStartDate = _a.currentStartDate, currentEndDate = _a.currentEndDate;
            var realMin = min;
            if (pickerType === 'end') {
                if (currentStartDate) {
                    realMin = currentStartDate;
                }
                if (currentStartDate &&
                    min &&
                    (0, dayjs_1.default)(currentStartDate).isAfter((0, dayjs_1.default)(min))) {
                    realMin = currentStartDate;
                }
            }
            //@ts-ignore
            var res = realMin ? (0, dayjs_1.default)(realMin) : (0, dayjs_1.default)().subtract(10, 'year');
            // 从end切回start的情况，end取了打开时的十年前，min再取当前时间十年前会出现>max的情况
            if (currentEndDate && res.isAfter(currentEndDate)) {
                res = (0, dayjs_1.default)(currentEndDate);
            }
            return res;
        },
        getMax: function () {
            var max = this.props.max;
            var _a = this.data, pickerType = _a.pickerType, currentEndDate = _a.currentEndDate;
            var realMax = max;
            if (pickerType === 'start') {
                if (currentEndDate) {
                    realMax = currentEndDate;
                }
                if (currentEndDate &&
                    max &&
                    (0, dayjs_1.default)(currentEndDate).isBefore((0, dayjs_1.default)(max))) {
                    realMax = currentEndDate;
                }
            }
            //@ts-ignore
            return realMax ? (0, dayjs_1.default)(realMax) : (0, dayjs_1.default)().add(10, 'year');
        },
        // didUpdate、弹窗打开、切换pickerType触发
        setCurrentValue: function () {
            var _this = this;
            var _visible = this._visible; // 隐藏状态下从CValue触发，展开状态使用当前数据
            var precision = this.props.precision;
            var _a = this.data, cValue = _a.cValue, pickerType = _a.pickerType, columns = _a.columns;
            var _b = this.data, currentStartDate = _b.currentStartDate, currentEndDate = _b.currentEndDate;
            var currentStartDateByCValue = (cValue === null || cValue === void 0 ? void 0 : cValue[0]) || null;
            var currentEndDateByCValue = (cValue === null || cValue === void 0 ? void 0 : cValue[1]) || null;
            // 展开状态，说明在切换pickerType
            if (_visible) {
                if (pickerType === 'start') {
                    // currentStartDate 无需变化
                }
                else {
                    // pickerType=end start已存在
                    // 结束时间默认选中开始
                    if (!currentEndDate) {
                        currentEndDate = currentStartDate;
                    }
                }
            }
            else {
                // 否则是在从cValue初始化
                currentStartDate = currentStartDateByCValue;
                currentEndDate = currentEndDateByCValue;
                // 开始默认取优先取当前时间，不在时间范围内取开始时间
                if (!currentStartDate) {
                    var min = this.getMin().toDate();
                    var max = this.props.max;
                    currentStartDate = new Date();
                    if ((min && currentStartDate < min) ||
                        (max && currentStartDate > max) ||
                        (currentEndDateByCValue &&
                            currentStartDate > currentEndDateByCValue)) {
                        currentStartDate = min;
                    }
                }
            }
            var currentValue = (0, util_1.getValueByDate)(pickerType === 'start' ? currentStartDate : currentEndDate, precision);
            var newColumns = this.generateData(currentValue);
            if (!(0, fast_deep_equal_1.default)(newColumns, columns)) {
                this.setData({ columns: newColumns }, function () {
                    _this.setData({ currentStartDate: currentStartDate, currentEndDate: currentEndDate, currentValue: currentValue });
                });
            }
            else {
                this.setData({ currentStartDate: currentStartDate, currentEndDate: currentEndDate, currentValue: currentValue });
            }
        },
        /**
         * 生成选项数据，didmound、picker change、打开弹窗、切换picker type触发
         */
        generateData: function (currentValue) {
            var precision = this.props.precision;
            var min = this.getMin();
            var max = this.getMax();
            if (max < min) {
                return [];
            }
            var currentPickerDay = (0, dayjs_1.default)();
            if (currentValue.length > 0) {
                currentPickerDay = (0, dayjs_1.default)((0, util_1.getDateByValue)(currentValue));
            }
            if (currentPickerDay < min || currentPickerDay > max) {
                currentPickerDay = min;
            }
            var newColumns = (0, util_1.getRangeData)(precision, min, max, currentPickerDay);
            return newColumns;
        },
        onChange: function (selectedIndex) {
            var _this = this;
            selectedIndex = (0, util_1.getValidValue)(selectedIndex);
            var _a = this.props, onPickerChange = _a.onPickerChange, format = _a.format, precision = _a.precision;
            var date = (0, util_1.getDateByValue)(selectedIndex);
            var min = this.getMin();
            var max = this.getMax();
            if ((0, dayjs_1.default)(date).isBefore(min)) {
                date = min.toDate();
                selectedIndex = (0, util_1.getValueByDate)(date, precision);
            }
            if ((0, dayjs_1.default)(date).isAfter(max)) {
                date = max.toDate();
                selectedIndex = (0, util_1.getValueByDate)(date, precision);
            }
            var _b = this.data, pickerType = _b.pickerType, columns = _b.columns;
            var newData = {
                currentValue: selectedIndex,
            };
            if (pickerType === 'start') {
                newData.currentStartDate = date;
            }
            else {
                newData.currentEndDate = date;
            }
            var newColumns = this.generateData(selectedIndex);
            if (!(0, fast_deep_equal_1.default)(newColumns, columns)) {
                this.setData({
                    columns: newColumns,
                }, function () {
                    _this.setData(newData);
                    if (onPickerChange) {
                        onPickerChange(pickerType, date, (0, dayjs_1.default)(date).format(format), selectedIndex, (0, fmtEvent_1.default)(_this.props));
                    }
                });
            }
            else {
                this.setData(newData);
                if (onPickerChange) {
                    onPickerChange(pickerType, date, (0, dayjs_1.default)(date).format(format), selectedIndex, (0, fmtEvent_1.default)(this.props));
                }
            }
        },
        onDismiss: function (e) {
            var onDismiss = this.props.onDismiss;
            if (onDismiss) {
                onDismiss((0, fmtEvent_1.default)(this.props, e));
            }
        },
        onOk: function () {
            var _a = this.props, format = _a.format, precision = _a.precision;
            var _b = this.data, currentStartDate = _b.currentStartDate, currentEndDate = _b.currentEndDate;
            var cValue = [currentStartDate, currentEndDate];
            this.setData({ cValue: cValue });
            if (this.props.onOk) {
                this.props.onOk(cValue, cValue.map(function (v) { return (0, dayjs_1.default)(v).format(format); }), cValue.map(function (v) { return (0, util_1.getValueByDate)(v, precision); }), (0, fmtEvent_1.default)(this.props));
            }
        },
        onFormat: function () {
            var _a = this.props, onFormat = _a.onFormat, format = _a.format, precision = _a.precision, value = _a.value;
            var cValue = this.data.cValue;
            var realValue = cValue && cValue[0] && cValue[1] ? cValue : value;
            return onFormat.call(this, realValue, realValue
                ? realValue.map(function (v) { return (v ? (0, dayjs_1.default)(v).format(format) : null); })
                : null, realValue
                ? realValue.map(function (v) { return (v ? (0, util_1.getValueByDate)(v, precision) : null); })
                : null);
        },
        /**
         * 显示/隐藏切换
         * @param visible
         */
        onTriggerPicker: function (visible) {
            var onTriggerPicker = this.props.onTriggerPicker;
            if (visible) {
                this.setData({ pickerType: 'start' });
                this.setCurrentValue();
            }
            if (onTriggerPicker) {
                onTriggerPicker(visible, (0, fmtEvent_1.default)(this.props));
            }
            this._visible = visible;
        },
        onChangeCurrentPickerType: function (e) {
            var type = e.target.dataset.type;
            var pickerType = this.data.pickerType;
            if (type !== pickerType) {
                this.setData({
                    pickerType: type,
                });
                this.setCurrentValue();
            }
        },
    },
});