"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var props_1 = require("./props");
var context_1 = require("./context");
var tools_1 = require("../_util/tools");
Component({
    props: props_1.VTabsDefaultProps,
    data: {
        tabTop: 0,
        _tabs: {},
        _index: 0,
        wrapScrollTop: null,
        wrapScrollHeight: null,
    },
    didMount: function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var index;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.isScrolling = false;
                        this.onlyChangeTab = false;
                        this.timerId = null;
                        return [4 /*yield*/, this.calcHeight()];
                    case 1:
                        _a.sent();
                        context_1.componentContext.onUpdate(function (value) {
                            _this.setData({
                                _tabs: value,
                            });
                        });
                        index = this.props.index;
                        this.setData({
                            _tabs: (0, tools_1.objectValues)(context_1.getTabArray),
                            wrapScrollHeight: this.scrollWrapHeight,
                        });
                        // 初次加载时的情况
                        if (this.data._index !== index) {
                            this.onChange(index);
                            this.setData({
                                _index: index,
                            });
                        }
                        return [2 /*return*/];
                }
            });
        });
    },
    didUpdate: function (prevProps, prevData) {
        var index = this.props.index;
        var _index = this.data._index;
        if (prevProps.index !== index && prevData._index === _index) {
            this.onChange(index);
        }
    },
    didUnmount: function () {
        context_1.componentContext.clearEvent();
        if (this.timerId) {
            clearTimeout(this.timerId);
            this.timerId = null;
        }
    },
    methods: {
        onWrapTouchStart: function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.calcHeight()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        },
        calcHeight: function () {
            var _a;
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _b, _c, rects, prevHeight, i, height;
                var _this = this;
                return tslib_1.__generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            this.anchorMap = {};
                            this.indexTop = {};
                            this.indexMap = {};
                            _b = this;
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    my.createSelectorQuery()
                                        .select("#amd-vtabs-content-slides-".concat(_this.$id))
                                        .boundingClientRect()
                                        .exec(function (ret) {
                                        resolve(ret[0].height);
                                    });
                                })];
                        case 1:
                            _b.wrapHeight = _d.sent();
                            _c = this;
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    my.createSelectorQuery()
                                        .select("#amd-vtabs-content-slides-".concat(_this.$id))
                                        .scrollOffset()
                                        .exec(function (ret) {
                                        resolve(ret[0].scrollTop);
                                    });
                                })];
                        case 2:
                            _c.wrapTop = _d.sent();
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    my.createSelectorQuery()
                                        .selectAll("#amd-vtabs-content-slides-".concat(_this.$id, " .amd-vtabs-item"))
                                        .boundingClientRect()
                                        .exec(function (res) {
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        resolve(res[0].sort(function (a, b) { return a.top - b.top; }));
                                    });
                                })];
                        case 3:
                            rects = _d.sent();
                            prevHeight = 0;
                            for (i = 0; i < rects.length; i += 1) {
                                height = rects[i].height;
                                this.anchorMap[i] = Math.floor(prevHeight);
                                this.indexMap[i] = Math.floor(height);
                                if (i === 0) {
                                    this.indexTop[0] = 0;
                                }
                                else {
                                    this.indexTop[i] = this.indexTop[i - 1] + ((_a = rects[i - 1]) === null || _a === void 0 ? void 0 : _a.height);
                                }
                                prevHeight += height;
                                this.scrollWrapHeight = prevHeight;
                            }
                            return [2 /*return*/];
                    }
                });
            });
        },
        onChange: function (e) {
            var _a, _b, _c;
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var index;
                return tslib_1.__generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, this.calcHeight()];
                        case 1:
                            _d.sent();
                            if (typeof e === 'number' && !isNaN(e)) {
                                index = e;
                                this.setData({
                                    _index: index,
                                });
                                this.moveScrollBar(index);
                            }
                            else {
                                index = (_b = (_a = e === null || e === void 0 ? void 0 : e.currentTarget) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b.payload;
                                if ((_c = this.data._tabs[index]) === null || _c === void 0 ? void 0 : _c.disabled) {
                                    return [2 /*return*/];
                                }
                            }
                            if (!this.isScrolling || this.onlyChangeTab) {
                                this.setData({
                                    wrapScrollTop: { _v: this.indexTop[index] },
                                });
                                this.curScrollBarIndex = index;
                                this.moveScrollBar(index);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        },
        moveScrollBar: function (current) {
            var onChange = this.props.onChange;
            var tabTop;
            // tabTop 用来控制侧边 tab 的 scroll-view 滚动位置
            if (current < 6) {
                tabTop = 0;
            }
            else {
                tabTop = (current - 5) * 55;
            }
            // vtabItem 滚动时，对侧边 tab 的影响
            if (this.data._index !== current) {
                if (onChange) {
                    onChange(current);
                }
                this.setData({
                    _index: current,
                });
            }
            this.setData({
                tabTop: tabTop,
            });
        },
        onScroll: function (e) {
            var _this = this;
            var scrollTop = e.detail.scrollTop;
            var keys = Object.keys(this.anchorMap);
            if (this.timerId) {
                clearTimeout(this.timerId);
                this.timerId = null;
            }
            this.timerId = setTimeout(function () {
                _this.isScrolling = false;
            }, 100);
            var anchorLength = keys.length;
            for (var i = 0; i < anchorLength; i++) {
                if (i === anchorLength - 1) {
                    // 如果是最后一个只需满足 scrollTop 高于当前 vtabItem 的高度
                    if (scrollTop >= this.anchorMap[keys[i]]) {
                        this.moveScrollBar(i);
                        break;
                    }
                }
                if (scrollTop >= this.anchorMap[keys[i]] &&
                    scrollTop < this.anchorMap[keys[i + 1]]) {
                    // 如果每个 vtabItem 高度小于 scroll-view 高度，到达底部后就不需要根据 scrollTop 再去判断左侧的选择项
                    if (scrollTop + this.wrapHeight < this.scrollWrapHeight) {
                        this.moveScrollBar(this.curScrollBarIndex || i);
                        // 滚动时清空点击左侧bar的数据
                        this.curScrollBarIndex = '';
                    }
                    break;
                }
            }
        },
        onWrapTouchMove: function () {
            this.isScrolling = true;
            this.onlyChangeTab = true;
        },
    },
});