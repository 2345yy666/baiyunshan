"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fast_deep_equal_1 = tslib_1.__importDefault(require("fast-deep-equal"));
var debounce_1 = tslib_1.__importDefault(require("../_util/debounce"));
var props_1 = require("./props");
/**
 * 每个sideBarItem的高度
 */
var DEVIATION = 8;
Component({
    props: props_1.BladeViewDefaultProps,
    data: {
        currentKey: '',
        scrollTop: 0,
        isTouchingSideBar: false
    },
    didMount: function () {
        var _this = this;
        this.computeTopRange();
        this.computeSideBar();
        this.debounce = (0, debounce_1.default)(function (func) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            func.call.apply(func, tslib_1.__spreadArray([_this], rest, false));
        }, 50);
    },
    didUpdate: function (prevProps) {
        /**
         * 数据源变化时需要重新计算高度
         */
        if (!(0, fast_deep_equal_1.default)(prevProps.data, this.props.data)) {
            this.computeTopRange();
            this.computeSideBar();
        }
    },
    methods: {
        /**
         * 渲染后计算每个group距离容器顶部的top值，并设置currentKey
         */
        computeTopRange: function () {
            var _this = this;
            my.createSelectorQuery()
                .selectAll('.amd-blade-view-body-group')
                .boundingClientRect()
                .exec(function (res) {
                if (res[0] === null)
                    throw new Error('找不到元素');
                _this.topRange = res[0].reduce(function (pre, cur) {
                    pre.push({
                        id: cur.id || "amd-blade-view-group-".concat(cur.dataset.key),
                        key: cur.dataset.key,
                        height: cur.height,
                        top: cur.height + (pre && pre["".concat(pre.length - 1)] && pre["".concat(pre.length - 1)].top || 0),
                    });
                    return pre;
                }, []);
                /**
                 * 初始化时设置currentKey
                 */
                var scrollToKey = _this.props.scrollToKey;
                var findItem = _this.topRange.find(function (item) { return item.key === scrollToKey; });
                _this.setData({
                    currentKey: scrollToKey || (_this.props.data && _this.props.data[0] && _this.props.data[0].key || ''),
                    scrollTop: scrollToKey ? findItem.top - findItem.height : 0,
                });
            });
        },
        /**
         * 渲染后找出sidebar中的每个item按钮距离页面上边距的top值
         */
        computeSideBar: function () {
            var _this = this;
            my.createSelectorQuery()
                .selectAll('.amd-blade-view-sidebar-item')
                .boundingClientRect()
                .exec(function (res) {
                if (res[0] === null)
                    throw new Error('找不到元素');
                _this.sidebarDistance = res[0].map(function (item) { return ({ top: item.top, key: item.dataset.key }); });
            });
        },
        setNotScrolling: function () {
            this.isScrolling = false;
        },
        /**
         * 滚动监听
         */
        onScroll: function (e) {
            /**
             * 判断是否正在滚动
             */
            this.isScrolling = true;
            this.debounce(this.setNotScrolling);
            var scrollTop = e.detail.scrollTop;
            /**
             * 标题和sidebar联动
             */
            var currentKey = this.topRange.find(function (item) { return scrollTop < item.top - DEVIATION; }).key;
            if (this.data.currentKey === currentKey)
                return;
            this.setData({
                currentKey: currentKey
            });
        },
        /**
         * 点击sidebar
         */
        onTapSideItem: function (e, moveKey) {
            /**
             * 如果容器正在滚动是不能触发侧边栏点击的，否则会导致逻辑混乱
             */
            if (this.isScrolling)
                return;
            var key = e && e.target && e.target.dataset && e.target.dataset.key || moveKey;
            if (key === this.data.currentKey)
                return;
            var findItem = this.topRange.find(function (item) { return item.key === key; });
            var scrollTop = findItem.top - findItem.height;
            this.setData({
                currentKey: key,
                scrollTop: scrollTop + Number(this.data.scrollTop === scrollTop),
            });
        },
        onTouchMove: function (e) {
            var currentY = e.changedTouches[0].pageY;
            var moveOnElement = this.sidebarDistance.find(function (item) { return currentY < item.top + DEVIATION; }) ||
                this.sidebarDistance[this.sidebarDistance.length - 1];
            /**
             * 触摸到某个节点，就触发点击选中事件（根据 sidebar中的item距离页面顶部距离 和 触摸时手指距离页面顶部距离 来找出触摸到了哪个item）
             */
            this.onTapSideItem(undefined, moveOnElement.key);
        },
        onTouchStart: function () {
            this.setData({ isTouchingSideBar: true });
        },
        onTouchEnd: function () {
            this.setData({ isTouchingSideBar: false });
        },
        onTapItem: function (e) {
            var _a = e.target.dataset, item = _a.item, group = _a.group;
            var onChange = this.props.onChange;
            onChange && onChange(item, group);
        },
    },
});