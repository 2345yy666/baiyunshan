"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var props_1 = require("./props");
Component({
    props: props_1.ProgressDefaultProps,
    data: {
        canvasWidth: 100,
        canvasHeight: 100,
    },
    ctx: null,
    canvas: null,
    didMount: function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.updateProgress(0);
                return [2 /*return*/];
            });
        });
    },
    didUpdate: function (prev) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (this.props.percent !== prev.percent) {
                    this.updateProgress(prev.percent);
                }
                return [2 /*return*/];
            });
        });
    },
    methods: {
        getCanvasContext: function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var systemInfo, pixelRatio;
                var _this = this;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.ctx)
                                return [2 /*return*/];
                            return [4 /*yield*/, my.getSystemInfo()];
                        case 1:
                            systemInfo = _a.sent();
                            pixelRatio = systemInfo.pixelRatio;
                            return [2 /*return*/, new Promise(function (resolve, reject) {
                                    _this.ctx = my.createCanvasContext("progressbar-canvas-".concat(_this.$id));
                                    _this.ctx.imageSmoothingEnabled = true;
                                    _this.ctx.imageSmoothingQuality = 'high';
                                    my.createSelectorQuery().select(".amd-progressbar-wrapper").boundingClientRect().exec(function (res) {
                                        var _a = res[0], width = _a.width, height = _a.height;
                                        _this.setData({
                                            canvasHeight: height * pixelRatio,
                                            canvasWidth: width * pixelRatio,
                                            pixelRatio: pixelRatio
                                        });
                                        resolve();
                                    });
                                })];
                    }
                });
            });
        },
        updateProgress: function (prev) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var curRad, targetRad, direction, draw;
                var _this = this;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.getCanvasContext()];
                        case 1:
                            _a.sent();
                            curRad = Math.floor(prev / 100 * 360);
                            targetRad = Math.floor(this.props.percent / 100 * 360);
                            direction = curRad < targetRad ? 1 : -1;
                            draw = function () {
                                if (curRad == targetRad)
                                    return;
                                curRad = direction * _this.props.speed + curRad;
                                if (direction == -1) {
                                    curRad = Math.max(curRad, targetRad);
                                }
                                else {
                                    curRad = Math.min(curRad, targetRad);
                                }
                                _this.clearCanvas();
                                _this.drawOrbit();
                                _this.drawProgress(curRad);
                                _this.ctx.draw(true);
                                _this.requestAnimationFrame(draw);
                            };
                            draw();
                            return [2 /*return*/];
                    }
                });
            });
        },
        requestAnimationFrame: function (fn) {
            setTimeout(fn, 16);
        },
        drawProgress: function (rad) {
            if (rad === void 0) { rad = 0; }
            var ctx = this.ctx;
            var _a = this.data, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
            ctx.beginPath();
            ctx.strokeStyle = (this.props.progressColor);
            ctx.lineWidth = (this.props.progressWidth);
            ctx.setLineCap("round");
            ctx.arc(canvasWidth / 2, canvasHeight / 2, canvasWidth / 2 - this.props.progressWidth, -Math.PI / 2, -Math.PI / 2 + rad / 360 * 2 * Math.PI, false);
            ctx.stroke();
        },
        drawOrbit: function () {
            var ctx = this.ctx;
            var _a = this.data, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
            ctx.beginPath();
            ctx.strokeStyle = (this.props.orbitColor);
            ctx.lineWidth = (this.props.progressWidth);
            ctx.arc(canvasWidth / 2, canvasHeight / 2, canvasWidth / 2 - this.props.progressWidth, 0, Math.PI * 2, false);
            ctx.stroke();
        },
        clearCanvas: function () {
            var ctx = this.ctx;
            var _a = this.data, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        }
    }
});